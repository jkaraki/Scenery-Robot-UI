{"ast":null,"code":"import _defineProperty from \"/Users/josephkaraki/GitHub/Scenery-Robot-V3/client-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"/Users/josephkaraki/GitHub/Scenery-Robot-V3/client-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/josephkaraki/GitHub/Scenery-Robot-V3/client-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/josephkaraki/GitHub/Scenery-Robot-V3/client-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/josephkaraki/GitHub/Scenery-Robot-V3/client-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/josephkaraki/GitHub/Scenery-Robot-V3/client-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nvar _jsxFileName = \"/Users/josephkaraki/GitHub/Scenery-Robot-V3/client-master/src/App/pages/Bezier.js\";\nimport React, { Component } from \"react\";\n\nvar Bezier =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(Bezier, _React$PureComponent);\n\n  function Bezier(props) {\n    var _this;\n\n    _classCallCheck(this, Bezier);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Bezier).call(this, props));\n    _this.state = {\n      // These are our 3 Bézier points, stored in state.\n      startPoint: {\n        x: 10,\n        y: 10\n      },\n      controlPoint: {\n        x: 190,\n        y: 100\n      },\n      endPoint: {\n        x: 10,\n        y: 190\n      },\n      // We keep track of which point is currently being\n      // dragged. By default, no point is.\n      draggingPointId: null\n    };\n    return _this;\n  }\n\n  _createClass(Bezier, [{\n    key: \"handleMouseDown\",\n    value: function handleMouseDown(pointId) {\n      this.setState({\n        draggingPointId: pointId\n      });\n    }\n  }, {\n    key: \"handleMouseUp\",\n    value: function handleMouseUp() {\n      this.setState({\n        draggingPointId: null\n      });\n    }\n  }, {\n    key: \"handleMouseMove\",\n    value: function handleMouseMove(_ref) {\n      var clientX = _ref.clientX,\n          clientY = _ref.clientY;\n      var _this$props = this.props,\n          viewBoxWidth = _this$props.viewBoxWidth,\n          viewBoxHeight = _this$props.viewBoxHeight;\n      var draggingPointId = this.state.draggingPointId; // If we're not currently dragging a point, this is\n      // a no-op. Nothing needs to be done.\n\n      if (!draggingPointId) {\n        return;\n      } // During render, we capture a reference to the SVG\n      // we're drawing, and store it on the instance with\n      // `this.node`.\n      // If we were to `console.log(this.node)`, we'd see a\n      // reference to the underlying HTML element.\n      // eg. `<svg viewBox=\"0 0 250 250\"\n\n\n      var svgRect = this.node.getBoundingClientRect();\n      /*\n      Ok, this next bit requires some explanation.\n         The SVG rect gives us the element's position relative\n      to the viewport.\n         The user's mouse position with `clientX` and `clientY`\n      is also relative to the viewport.\n         What we actually care about, though, is the cursor's\n      position relative to the SVG itself.\n         Let's use a diagram! Imagine if ⬁ is the user's cursor:\n            ------------------------------------------------------\n      | viewport            ______________                 |\n      |                    |              |                |\n      |                    |       ⬁      | <- SVG         |\n      |                    |______________|                |\n      |____________________________________________________|\n         ^----------------------------^ This is the `clientX`;\n                                     the distance between the\n                                     viewport and the cursor.\n         ^-------------------^          This is the `svgRect`\n                                     `left` value. Distance\n                                     between the viewport and\n                                     the SVG's left edge.\n                             ^--------^ This is the distance we\n                                     care about; the distance\n                                     between the SVG's left\n                                     edge, and the cursor.\n         We can get that value with subtraction!\n      */\n\n      var svgX = clientX - svgRect.left;\n      var svgY = clientY - svgRect.top;\n      /*\n      The next problem is that our SVG has a different\n      coordinate system: Our SVG's `viewBox` might be 250x250,\n      while in terms of the screen real-estate it might\n      actually take up 500x500 pixels!\n         To solve for this, I used cross-multiplication. Here are\n      the variables we need:\n         - svgX            The value we just calculated. The\n                        cursor's `x` position within the SVG.\n         - viewBoxWidth    The width of the SVG's internal\n                        coordinate system. Specified via\n                        props to this component.\n         - svgRect.width   The on-screen width of the DOM element\n                        Returned from `getBoundingClientRect`.\n         Armed with that data, we can cross-multiply as follows:\n              svgX               viewBoxX (unknown)\n      --------------    =    --------------------\n       viewBoxWidth             svgRect.width\n         The left side of this equation is in terms of the screen\n      real-estate: our cursor might be 250px into a 500px-wide\n      svg.\n         The right side is the SVG's viewBox coordinate system.\n      We're `X` pixels into a 250px-wide viewBox.\n         When we re-arrange the formula to solve for `viewBoxX`,\n      we wind up with:\n      */\n\n      var viewBoxX = svgX * viewBoxWidth / svgRect.width; // We do the same thing for the vertical direction:\n\n      var viewBoxY = svgY * viewBoxHeight / svgRect.height; // Phew! That was a lot of stuff, but in the end we\n      // wind up with the user's mouse position within the\n      // SVG's viewBox, and can update React state so that it\n      // re-renders in this new position!\n\n      this.setState(_defineProperty({}, draggingPointId, {\n        x: viewBoxX,\n        y: viewBoxY\n      }));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var viewBoxWidth = 250;\n      var viewBoxHeight = 250;\n      var _this$state = this.state,\n          startPoint = _this$state.startPoint,\n          controlPoint = _this$state.controlPoint,\n          endPoint = _this$state.endPoint; // As we've seen before, the quadratic Bézier curve\n      // involves moving to the starting point, and then\n      // specifying the control and end points with `Q`\n\n      var instructions = \"\\n        M \".concat(startPoint.x, \",\").concat(startPoint.y, \"\\n        Q \").concat(controlPoint.x, \",\").concat(controlPoint.y, \"\\n          \").concat(endPoint.x, \",\").concat(endPoint.y, \"\\n      \"); // While the Bézier curve is the main attraction,\n      // we also have several shapes, including:\n      //   - the handles for the start/control/end points\n      //   - the dashed line that shows how the control\n      //     point connects to the start/end points.\n\n      return React.createElement(\"svg\", {\n        ref: function ref(node) {\n          return _this2.node = node;\n        },\n        viewBox: \"0 0 \".concat(viewBoxWidth, \" \").concat(viewBoxHeight),\n        onMouseMove: function onMouseMove(ev) {\n          return _this2.handleMouseMove(ev);\n        },\n        onMouseUp: function onMouseUp() {\n          return _this2.handleMouseUp();\n        },\n        onMouseLeave: function onMouseLeave() {\n          return _this2.handleMouseUp();\n        },\n        style: {\n          overflow: 'visible'\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 160\n        },\n        __self: this\n      }, React.createElement(ConnectingLine, {\n        from: startPoint,\n        to: controlPoint,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 168\n        },\n        __self: this\n      }), React.createElement(ConnectingLine, {\n        from: controlPoint,\n        to: endPoint,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 172\n        },\n        __self: this\n      }), React.createElement(Curve, {\n        instructions: instructions,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 174\n        },\n        __self: this\n      }), React.createElement(LargeHandle, {\n        coordinates: startPoint,\n        onMouseDown: function onMouseDown() {\n          return _this2.handleMouseDown('startPoint');\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 176\n        },\n        __self: this\n      }), React.createElement(LargeHandle, {\n        coordinates: endPoint,\n        onMouseDown: function onMouseDown() {\n          return _this2.handleMouseDown('endPoint');\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 183\n        },\n        __self: this\n      }), React.createElement(SmallHandle, {\n        coordinates: controlPoint,\n        onMouseDown: function onMouseDown() {\n          return _this2.handleMouseDown('controlPoint');\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 190\n        },\n        __self: this\n      }));\n    }\n  }]);\n\n  return Bezier;\n}(React.PureComponent); // These helper stateless-functional-components allow us\n// to reuse styles, and give each shape a meaningful name.\n\n\nvar ConnectingLine = function ConnectingLine(_ref2) {\n  var from = _ref2.from,\n      to = _ref2.to;\n  return React.createElement(\"line\", {\n    x1: from.x,\n    y1: from.y,\n    x2: to.x,\n    y2: to.y,\n    stroke: \"rgb(200, 200, 200)\",\n    strokeDasharray: \"5,5\",\n    strokeWidth: 2,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 205\n    },\n    __self: this\n  });\n};\n\nvar Curve = function Curve(_ref3) {\n  var instructions = _ref3.instructions;\n  return React.createElement(\"path\", {\n    d: instructions,\n    fill: \"none\",\n    stroke: \"rgb(213, 0, 249)\",\n    strokeWidth: 5,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 217\n    },\n    __self: this\n  });\n};\n\nvar LargeHandle = function LargeHandle(_ref4) {\n  var coordinates = _ref4.coordinates,\n      onMouseDown = _ref4.onMouseDown;\n  return React.createElement(\"ellipse\", {\n    cx: coordinates.x,\n    cy: coordinates.y,\n    rx: 15,\n    ry: 15,\n    fill: \"rgb(244, 0, 137)\",\n    onMouseDown: onMouseDown,\n    style: {\n      cursor: '-webkit-grab'\n    },\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 226\n    },\n    __self: this\n  });\n};\n\nvar SmallHandle = function SmallHandle(_ref5) {\n  var coordinates = _ref5.coordinates,\n      onMouseDown = _ref5.onMouseDown;\n  return React.createElement(\"ellipse\", {\n    cx: coordinates.x,\n    cy: coordinates.y,\n    rx: 8,\n    ry: 8,\n    fill: \"rgb(255, 255, 255)\",\n    stroke: \"rgb(244, 0, 137)\",\n    strokeWidth: 2,\n    onMouseDown: onMouseDown,\n    style: {\n      cursor: '-webkit-grab'\n    },\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 238\n    },\n    __self: this\n  });\n};\n\nrender(React.createElement(Bezier, {\n  viewBoxWidth: 250,\n  viewBoxHeight: 250,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 250\n  },\n  __self: this\n}));","map":{"version":3,"sources":["/Users/josephkaraki/GitHub/Scenery-Robot-V3/client-master/src/App/pages/Bezier.js"],"names":["React","Component","Bezier","props","state","startPoint","x","y","controlPoint","endPoint","draggingPointId","pointId","setState","clientX","clientY","viewBoxWidth","viewBoxHeight","svgRect","node","getBoundingClientRect","svgX","left","svgY","top","viewBoxX","width","viewBoxY","height","instructions","ev","handleMouseMove","handleMouseUp","overflow","handleMouseDown","PureComponent","ConnectingLine","from","to","Curve","LargeHandle","coordinates","onMouseDown","cursor","SmallHandle","render"],"mappings":"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","sourcesContent":["\nimport React, { Component } from \"react\";\n\nclass Bezier extends React.PureComponent {\n    constructor(props) {\n      super(props);\n  \n      this.state = {\n        // These are our 3 Bézier points, stored in state.\n        startPoint: { x: 10, y: 10 },\n        controlPoint: { x: 190, y: 100 },\n        endPoint: { x: 10, y: 190 },\n  \n        // We keep track of which point is currently being\n        // dragged. By default, no point is.\n        draggingPointId: null,\n      };\n    }\n  \n    handleMouseDown(pointId) {\n      this.setState({ draggingPointId: pointId });\n    }\n  \n    handleMouseUp() {\n      this.setState({ draggingPointId: null });\n    }\n  \n    handleMouseMove({ clientX, clientY }) {\n      const { viewBoxWidth, viewBoxHeight } = this.props;\n      const { draggingPointId } = this.state;\n  \n      // If we're not currently dragging a point, this is\n      // a no-op. Nothing needs to be done.\n      if (!draggingPointId) {\n        return;\n      }\n  \n      // During render, we capture a reference to the SVG\n      // we're drawing, and store it on the instance with\n      // `this.node`.\n      // If we were to `console.log(this.node)`, we'd see a\n      // reference to the underlying HTML element.\n      // eg. `<svg viewBox=\"0 0 250 250\"\n      const svgRect = this.node.getBoundingClientRect();\n  \n      /*\n      Ok, this next bit requires some explanation.\n  \n      The SVG rect gives us the element's position relative\n      to the viewport.\n  \n      The user's mouse position with `clientX` and `clientY`\n      is also relative to the viewport.\n  \n      What we actually care about, though, is the cursor's\n      position relative to the SVG itself.\n  \n      Let's use a diagram! Imagine if ⬁ is the user's cursor:\n  \n  \n      ------------------------------------------------------\n      | viewport            ______________                 |\n      |                    |              |                |\n      |                    |       ⬁      | <- SVG         |\n      |                    |______________|                |\n      |____________________________________________________|\n  \n      ^----------------------------^ This is the `clientX`;\n                                     the distance between the\n                                     viewport and the cursor.\n  \n      ^-------------------^          This is the `svgRect`\n                                     `left` value. Distance\n                                     between the viewport and\n                                     the SVG's left edge.\n  \n                          ^--------^ This is the distance we\n                                     care about; the distance\n                                     between the SVG's left\n                                     edge, and the cursor.\n  \n      We can get that value with subtraction!\n      */\n      const svgX = clientX - svgRect.left;\n      const svgY = clientY - svgRect.top;\n  \n      /*\n      The next problem is that our SVG has a different\n      coordinate system: Our SVG's `viewBox` might be 250x250,\n      while in terms of the screen real-estate it might\n      actually take up 500x500 pixels!\n  \n      To solve for this, I used cross-multiplication. Here are\n      the variables we need:\n  \n      - svgX            The value we just calculated. The\n                        cursor's `x` position within the SVG.\n  \n      - viewBoxWidth    The width of the SVG's internal\n                        coordinate system. Specified via\n                        props to this component.\n  \n      - svgRect.width   The on-screen width of the DOM element\n                        Returned from `getBoundingClientRect`.\n  \n      Armed with that data, we can cross-multiply as follows:\n  \n           svgX               viewBoxX (unknown)\n      --------------    =    --------------------\n       viewBoxWidth             svgRect.width\n  \n      The left side of this equation is in terms of the screen\n      real-estate: our cursor might be 250px into a 500px-wide\n      svg.\n  \n      The right side is the SVG's viewBox coordinate system.\n      We're `X` pixels into a 250px-wide viewBox.\n  \n      When we re-arrange the formula to solve for `viewBoxX`,\n      we wind up with:\n      */\n      const viewBoxX = svgX * viewBoxWidth / svgRect.width;\n  \n      // We do the same thing for the vertical direction:\n      const viewBoxY = svgY * viewBoxHeight / svgRect.height;\n  \n      // Phew! That was a lot of stuff, but in the end we\n      // wind up with the user's mouse position within the\n      // SVG's viewBox, and can update React state so that it\n      // re-renders in this new position!\n      this.setState({\n        [draggingPointId]: { x: viewBoxX, y: viewBoxY },\n      });\n    }\n  \n    render() {\n      const viewBoxWidth = 250;\n      const viewBoxHeight = 250;\n      const {\n        startPoint,\n        controlPoint,\n        endPoint,\n      } = this.state;\n  \n      // As we've seen before, the quadratic Bézier curve\n      // involves moving to the starting point, and then\n      // specifying the control and end points with `Q`\n      const instructions = `\n        M ${startPoint.x},${startPoint.y}\n        Q ${controlPoint.x},${controlPoint.y}\n          ${endPoint.x},${endPoint.y}\n      `;\n  \n      // While the Bézier curve is the main attraction,\n      // we also have several shapes, including:\n      //   - the handles for the start/control/end points\n      //   - the dashed line that shows how the control\n      //     point connects to the start/end points.\n      return (\n        <svg\n          ref={node => (this.node = node)}\n          viewBox={`0 0 ${viewBoxWidth} ${viewBoxHeight}`}\n          onMouseMove={ev => this.handleMouseMove(ev)}\n          onMouseUp={() => this.handleMouseUp()}\n          onMouseLeave={() => this.handleMouseUp()}\n          style={{ overflow: 'visible' }}\n        >\n          <ConnectingLine\n            from={startPoint}\n            to={controlPoint}\n          />\n          <ConnectingLine from={controlPoint} to={endPoint} />\n  \n          <Curve instructions={instructions} />\n  \n          <LargeHandle\n            coordinates={startPoint}\n            onMouseDown={() =>\n              this.handleMouseDown('startPoint')\n            }\n          />\n  \n          <LargeHandle\n            coordinates={endPoint}\n            onMouseDown={() =>\n              this.handleMouseDown('endPoint')\n            }\n          />\n  \n          <SmallHandle\n            coordinates={controlPoint}\n            onMouseDown={() =>\n              this.handleMouseDown('controlPoint')\n            }\n          />\n        </svg>\n      );\n    }\n  }\n  \n  // These helper stateless-functional-components allow us\n  // to reuse styles, and give each shape a meaningful name.\n  \n  const ConnectingLine = ({ from, to }) => (\n    <line\n      x1={from.x}\n      y1={from.y}\n      x2={to.x}\n      y2={to.y}\n      stroke=\"rgb(200, 200, 200)\"\n      strokeDasharray=\"5,5\"\n      strokeWidth={2}\n    />\n  );\n  \n  const Curve = ({ instructions }) => (\n    <path\n      d={instructions}\n      fill=\"none\"\n      stroke=\"rgb(213, 0, 249)\"\n      strokeWidth={5}\n    />\n  );\n  \n  const LargeHandle = ({ coordinates, onMouseDown }) => (\n    <ellipse\n      cx={coordinates.x}\n      cy={coordinates.y}\n      rx={15}\n      ry={15}\n      fill=\"rgb(244, 0, 137)\"\n      onMouseDown={onMouseDown}\n      style={{ cursor: '-webkit-grab' }}\n    />\n  );\n  \n  const SmallHandle = ({ coordinates, onMouseDown }) => (\n    <ellipse\n      cx={coordinates.x}\n      cy={coordinates.y}\n      rx={8}\n      ry={8}\n      fill=\"rgb(255, 255, 255)\"\n      stroke=\"rgb(244, 0, 137)\"\n      strokeWidth={2}\n      onMouseDown={onMouseDown}\n      style={{ cursor: '-webkit-grab' }}\n    />\n  );\nrender(<Bezier viewBoxWidth={250} viewBoxHeight={250} />);"]},"metadata":{},"sourceType":"module"}